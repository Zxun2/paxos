// number of nodes
#define N 8; 

// entities
#define PROPOSERS 2;
#define ACCEPTORS 3;
#define LEARNERS 2;

// message types
#define PASS 1000;
#define NACK -99;
#define FAIL -1000;
#define INACTIVE -999;
#define ACCEPTOR_FAILED -1001;

// acceptor states
var acceptor_prepare_status = [PASS(ACCEPTORS)];
var acceptor_can_broadcast = [NACK(ACCEPTORS)];
var acceptor_promised_id = [-1(N)];
var acceptor_accept_values = [-1(ACCEPTORS)];
var acceptor_accept_id = [-1(ACCEPTORS)];
var acceptor_status = [PASS(ACCEPTORS)];

// proposer states
var proposer_status = [PASS(PROPOSERS)];

// global state for proposer
var global_accepted_value = -1;
var global_elected_leader = 0;
var global_terminate = false;
var global_id = 0;

var hasNack = false;

var highest_id = -1;
var last_accepted = -1;

// client state
var client_proposed_value = -1;
var client_read_value = -1;
var client_consensus = -1;

// for validating quorums
var quorums = ACCEPTORS / 2 + 1;
var prepare_reads = 0;
var promise_received = 0;
var accept_reads = 0;
var accepted_received = 0;

var retry = false;

// channels
channel reset[ACCEPTORS] 0;
channel prepare_channel[ACCEPTORS] 0;
channel promise_channel[ACCEPTORS] 0;
channel accepted_channel_learner[LEARNERS] 0;
channel accepted_channel_proposer 0;
channel accept_channel [ACCEPTORS] 0;

channel client_proposer 0;
channel learner_client 0;

Proposer(state, i) = 
	if (global_elected_leader == i) {
		client_proposer?value {
			client_proposed_value = value
		} -> ProposerState(state, i) [] ([client_proposed_value != -1] ProposerState(state, i))
	} else {
		Skip
	};

ProposerState(state, curr) = 
	if (global_id >= state) {
		ProposerState(global_id + 1, curr)
	} else {
		// 1a. PREPARE
		SendPrepareMsg(state, curr);
		atomic { 
			if (prepare_reads < quorums) {
				atomic { PreparePhaseEnds() };
				atomic { (|||a:{0..ACCEPTORS-1}@(reset[a]!curr.FAIL -> Skip)) };
				ProposerState(state, curr) 
		}};
		if (prepare_reads >= quorums) {
			atomic { PreparePhaseEnds() };
			// 1b. PROMISE
			(|||y:{0..ACCEPTORS-1}@(promise_channel[y]?prev_promised_id.prev_acceptor_val.val{
				if (val == NACK) { global_terminate = true; global_id = prev_promised_id }
				if (val != INACTIVE && val != FAIL) { promise_received = promise_received + 1 }
			} -> Skip));
			atomic {
				if (promise_received < quorums) {
					atomic { 
						atomic { ResetPromiseReceived() };
						atomic { (|||a:{0..ACCEPTORS-1}@(reset[a]!curr.FAIL -> Skip)) }; // TODO: fix the reroute to tgt state 8 problem
						ProposerState(state, curr) 
					}
			}};
			if (promise_received >= quorums) {
				atomic { ResetPromiseReceived() };
				// since we have achieved quorum of acceptors
				// next request must be larger than current state
				if (global_terminate) {
					atomic { (|||a:{0..ACCEPTORS-1}@(reset[a]!curr.FAIL -> Skip)) };
					ProposerState(state, curr) // retry
				} else {
					atomic { promise_phase_ends { global_id = state } -> Skip };
					
					// if proposer fails BEFORE sending the first ACCEPT message
					// then there's no reason to proceed further because none of the acceptors will return a successful ACCEPTED message
					// hence we immediately reset the entire state
					(	// 2a. ACCEPT      				 // 2b. ACCEPTED 
						(SendsAcceptMsg(curr, state) ||| ((|||{ACCEPTORS}@(accepted_channel_proposer?val.status {
									if (status == PASS) { client_consensus = val };
//									if (status == NACK) { retry = true }
								} -> Skip)))); 
						atomic { end_of_broadcast -> Skip } ;
						if (global_terminate) {
							ElectNewLeader(state, curr)
						};
						if (retry) {
							atomic { (|||a:{0..ACCEPTORS-1}@(reset[a]!curr.FAIL -> Skip)) };
							// retry and elect ARE TWO DIFFERENT THINGS 
							// retry - proposer did not die
							// elect - proposer died
							ProposerState(state, curr) 
						}
					) 
				}
			}
		}
	};
	
ElectNewLeader(state, curr) = 
	if (curr == 0) {
		ElectNewLeaderRange(0, PROPOSERS - 1, state, curr)
	};
	
	if (curr == PROPOSERS - 1) {
		ElectNewLeaderRange(0, PROPOSERS - 2, state, curr)
	};
	
	if (0 < curr && curr < PROPOSERS - 1) {
		ElectNewLeaderRange(0, curr - 1, state, curr) [] 
		ElectNewLeaderRange(curr + 1, PROPOSERS - 1, state, curr) 
	};
	
ElectNewLeaderRange(low, high, state, curr) = 
	[]i:{low..high}@([proposer_status[i] == PASS]
		(|||a:{0..ACCEPTORS-1}@(reset[a]!i.FAIL -> Skip));
		elect_new_leader {
			global_elected_leader = i;
			global_terminate = false;
			proposer_status[global_elected_leader] = PASS;
			accept_reads = 0; // reset reads
		} -> (
			Proposer(acceptor_promised_id[i] + 1, i) |||
			(recover { 
					global_id = state; 
					hasNack = false;
					global_elected_leader = curr;
					proposer_status[curr] = PASS;
				}-> atomic { 
					(|||a:{0..ACCEPTORS-1}@(reset[a]!curr.FAIL -> Skip))};
					Proposer(state, curr)
				)
		)
	) ;
	
SendPrepareMsg(state, curr) = 
	atomic { |||x:{0..ACCEPTORS-1}@(prepare_channel[x]!curr.state.PASS -> Skip [] prepare_channel[x]!curr.state.FAIL -> Skip) };
	
PreparePhaseEnds() = 
	prepare_ends { prepare_reads = 0; } -> Skip;

ResetPromiseReceived() = 
	reset_promise_count { promise_received = 0 } -> Skip;

// if no value is accepted previously, use the client_proposed_value
SendsAcceptMsg(curr, state) =  // an accept message 
	if (global_accepted_value == -1) {
		// by not making it atomic, this allows next step to be triggered once quorum is achieved.
		// if atomic, we can only move on once all acceptors have sent their accept.
		(|||z:{0..ACCEPTORS-1}@accept_channel[z]!proposer_status[curr].state.client_proposed_value.acceptor_status[z] -> Skip) 
		||| ((proposer_fails { 
			global_terminate = true; 
			proposer_status[curr] = FAIL;
		} -> Skip) [] (proposer_did_not_fail_when_sending_accept -> Skip))
	} else {
		(|||z:{0..ACCEPTORS-1}@accept_channel[z]!proposer_status[curr].state.global_accepted_value.acceptor_status[z] -> Skip) 
		||| ((proposer_fails { 
			global_terminate = true; 
			proposer_status[curr] = FAIL;
		} -> Skip) [] (proposer_did_not_fail_when_sending_accept -> Skip))
	}; 

Acceptor(i) = AcceptorState(i);
	
AcceptorState(i) = 
	(ReceivePrepare(i);
	((	
		SendPromise(i);
		// after receiving accept message, we need to broadcast the accepted to learners and proposers. TODO: proposers
		// valid only if the status of broadcast accepted is PASS
		// proposer fails while sending accept, each accept has to be broadcasted if received. need to send values into channel.
		((ReceivesAcceptMsg(i); BroadcastAccepted(i)) [] ResetAcceptor(i, true))
	)  [] ResetAcceptor(i, true)); 
	[global_terminate || retry] ResetAcceptor(i, false));
	
ReceivePrepare(i) = 
	prepare_channel[i]?curr.state.status { 
		if (status == FAIL) {
			// by default, it's true, so we set to fail
			acceptor_prepare_status[i] = FAIL
		} else {
			// retrieve the previous promised id (meaning subsequent id has to be larger than this)
			var prev_id = acceptor_accept_id[i];
			// increment # of prepare reads
			prepare_reads = prepare_reads + 1;
			// retrive the previous *accepted* value
			last_accepted = acceptor_accept_values[i];
			
			// if acceptor previously already accepted some value, 
			// and previous promised id is larger than the current highest_id we seen so far
			// then override the global_accepted_value
			// this global_accepted_value is the one that the proposer will use
			// client_proposed_value < global_accepted_value
			if (last_accepted != -1 && prev_id > highest_id) {
				highest_id = prev_id;
				global_accepted_value = last_accepted;
			}
			
			// we dont update the acceptor internal state during the prepare phase
			// but we still do the check
			if (acceptor_promised_id[i] >= state) { 
				hasNack = true; 
			} else {
				acceptor_promised_id[i] = state;
			}
		}
	} -> Skip;
	
ResetAcceptor(i, clear) = 
	reset[i]?curr.x {
		acceptor_can_broadcast[i] = NACK;
		acceptor_prepare_status[i] = PASS;
		if (clear == true) {
			hasNack = false;
			global_terminate = false;
			retry = false;
		}
	} -> AcceptorState(i);
	
ReceivesAcceptMsg(i) =
	accept_channel[i]?proposer_alive.state.av.status {
		if (status == PASS && proposer_alive == PASS) {
			accept_reads = accept_reads + 1;
			if (global_terminate == false) {
				var currentId = acceptor_promised_id[i];
				if (state >= currentId) {
					acceptor_accept_values[i] = av; // update accepted value
					acceptor_accept_id[i] = state; // update accepted value
					acceptor_can_broadcast[i] = PASS;
				} else {
					retry = true; 
				}
			}
		}
	} -> Skip;
	
SendPromise(i) =
	if (acceptor_prepare_status[i] == FAIL || acceptor_status[i] == FAIL) {
		promise_channel[i]!acceptor_promised_id[i].acceptor_accept_values[i].INACTIVE-> Skip
	} else {
		([hasNack == true] promise_channel[i]!acceptor_promised_id[i].acceptor_accept_values[i].NACK -> Skip) []
		([hasNack == false] promise_channel[i]!acceptor_promised_id[i].acceptor_accept_values[i].PASS -> Skip) [] 
		(promise_channel[i]!acceptor_promised_id[i].acceptor_accept_values[i].FAIL -> Skip) [] 
		(promise_channel[i]!acceptor_promised_id[i].acceptor_accept_values[i].ACCEPTOR_FAILED { acceptor_status[i] = FAIL } -> Skip) 
	};
	
BroadcastAccepted(i) = 
	((|||q:{0..LEARNERS-1}@accepted_channel_learner[q]!acceptor_accept_values[i].acceptor_can_broadcast[i]-> Skip) |||
	(accepted_channel_proposer!acceptor_accept_values[i].acceptor_can_broadcast[i]-> Skip));

Learner(i) =
	(|||{ACCEPTORS}@(accepted_channel_learner[i]?val.status {
		if (status == PASS) {
			client_consensus = val
		}
	} -> Skip)); 
	atomic {
		if (client_consensus == -1) {
			Learner(i)
		} else {
			(([accept_reads >= quorums] learner_client!i.client_consensus -> Skip) [] ([accept_reads >= quorums] learner_client!i.FAIL -> Skip) [] (reset_learner -> Learner(i)))
		}
	};


Client(value) = (
		client_proposer!value -> Skip;
		(|||{LEARNERS}@(learner_client?i.x {
		 	if (x != FAIL) {
			 	client_read_value = x
			}       // after proposing a value, you can interrupt and propose a new value
			        // that way when the next reset point happens you can set a new value
		} -> Skip));
		finish { client_consensus = -1 } -> Skip
	)  interrupt propose_new_value -> Client(value + 1) ;

// entry point
System = Client(123) || Proposer(global_id + 1, 0) 
					 || (|||x:{0..ACCEPTORS-1}@Acceptor(x)) 
					 || (|||y:{0..LEARNERS-1}@Learner(y));


